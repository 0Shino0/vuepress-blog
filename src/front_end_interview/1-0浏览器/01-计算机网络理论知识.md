---

title: 说一下HTTP和HTTPS
tags: 
   - HTTP
categories: 
   - 浏览器
summary: 说一下HTTP和HTTPS
description: 说一下HTTP和HTTPS
date: 2023-12-13
---



# 说一下HTTP和HTTPS

HTTPS的SSL加密是在传输层实现的。
## 基本概念

1. HTTP： 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
2. HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。
3. HTTPS协议的主要作用：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。



## 区别

HTTP数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 HTTP协议传输的数据进行加密处理，简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比HTTP 协议安全性更高



### 主要区别

1. HTTPS协议需要ca证书，费用较高
2. HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议。 
3. 使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443
4. HTTP连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP安全。



## 工作原理

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤

1. 客户端使用https url访问服务器，则要求 web 服务器**建立 ssl 链接**。 
2. web 服务器接收到客户端的请求之后，会将网站的**证书**（证书中包含了公钥），**返回或者说传输给客户端**。 
3. 客户端和 web 服务器端开始**协商 SSL 链接的安全等级**，也就是加密等级。 
4. 客户端浏览器通过双方协商一致的安全等级，**建立会话密钥**，然后通过网站的公钥来**加密会话密钥**，并**传送给网站**。 
5. web 服务器通过自己的私钥解密出会话密钥。 
6. web 服务器通过会话密钥加密与客户端之间的通信。



## HTTPS的优点

1. 使用 HTTPS 协议**可认证用户和服务器**，**确保数据发送到正确的客户机和服务器**；
2. HTTPS 协议是由 SSL+HTTP 协议构建的可进行**加密传输、身份认证的网络协议**，要比 http 协议安全，**可防止数据在传输过程中不被窃取、改变，确保数据的完整性**。 
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 
4. 谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。



## HTTPS的缺点

1. **https 握手阶段比较费时**，会使页面加载时间延长 50%，增加 10%~20%的耗电。 
2. **https 缓存不如 http 高效**，会增加数据开销。 SSL 证书也需要钱，功能越强大的证书费用越高。 
3. **SSL 证书需要绑定 IP**，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。

# HTTP请求的方式_HEAD方式

head：类似于 get 请求，只不过返回的响应中没有具体的内容，用户获取报头 options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。

# 说一下HTTP2.0

简要概括：http2.0 是基于 1999 年发布的 http1.0 之后的首次更新

- **提升访问速度**（可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0） 
- **允许多路复用**：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。
- 改善了：**在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞**。 
- **二进制分帧**：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码首部压缩服务器端推送

# HTTP返回码

## 1XX

| 返回码 | 状态码英文               | 描述                                          |
| --- | ------------------- | ------------------------------------------- |
| 100 | Continue            | 继续。客户端应继续其请求                                |
| 101 | Switching Protocols | 切换协议。服务器根据客户端的请求切换协议。只能切换到更 高级的协议，例如，切换到 HT |

## 2XX

| 返回码 | 状态码英文                         | 描述                                                 |
| --- | ----------------------------- | -------------------------------------------------- |
| 200 | OK                            | 请求成功。一般用于 GET 与 POST 请求                            |
| 201 | Created                       | 创建。成功请求并创建了新的资源                                    |
| 202 | Accepted                      | 已接受。已经接受请求，但未处理完成                                  |
| 203 | Non-Authoritative Information | 非授权信息。请求成功。但返回的 meta 信息不在原 始的服务器，而是一个副本            |
| 204 | No Content                    | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下， 可确保浏览器继续显示当前文档      |
| 205 | Reset Content                 | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文 档视图。可通过此返回码清除浏览器的表单域 |
| 206 | Partial Content               | 部分内容。服务器成功处理了部分 GET 请求                             |

## 3XX

| 返回码 | 状态码英文               | 描述                                                                                 |
| --- | ------------------- | ---------------------------------------------------------------------------------- |
| 300 | Multiple Choices    | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特 征与地址的列表用于用户终端（例如：浏览器）选择                               |
| 301 | Moved Permanently   | 永久移动。请求的资源已被永久的移动到新 URI，返回信息会 包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替        |
| 302 | Found               | 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI                                            |
| 303 | See Other           | 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看                                                 |
| 304 | Not Modified        | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回 任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返 回在指定日期之后修改的资源 |
| 305 | Use Proxy           | 使用代理。所请求的资源必须通过代理访问                                                                |
| 306 | Unused              | 已经废弃的HTPP状态码                                                                       |
| 307 | Temporaty Redirrect | 临时重定向。与 302 类似。使用 GET 请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解                     |

## 4XX

| 返回码 | 状态码英文                           | 描述                                                                                 |
| --- | ------------------------------- | ---------------------------------------------------------------------------------- |
| 400 | Bad Request                     | 客户端请求的语法错误，服务器无法理解                                                                 |
| 401 | Unauthorized                    | 请求要求用户的身份认证                                                                        |
| 402 | Payment Required                | 保留，将来使用                                                                            |
| 403 | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求                                                            |
| 404 | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站 设计人员可设置"您所请求的资源无法找到"的个性页面                           |
| 405 | Method Not Allowed              | 客户端请求中的方法被禁止                                                                       |
| 406 | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                                                              |
| 407 | Proxy Authenticaltion           | 请求要求代理的身份认证，与 401 类似，但请求者 应当使用代理进行授权                                               |
| 408 | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                                                               |
| 409 | Conflict                        | 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发 生了冲突                                            |
| 410 | Gone                            | 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永 久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置      |
| 411 | Length Required                 | 服务器无法处理客户端发送的不带 Content-Length 的请求信                                                |
| 412 | Precondition Failed             | 客户端请求信息的先决条件错误                                                                     |
| 413 | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。 为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则 会包含一个 Retry-After |
| 414 | Request-URI Too Large           | 请求URL过长（URL通常为网址），服务器无法处理                                                          |
| 415 | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                                                                   |
| 416 | Requested range not satisfiable | 客户端请求的范围无效                                                                         |
| 417 | Expectation Failed              | 服务器不支持请求的功能，无法完成请求                                                                 |

## 5XX

| 返回码 | 状态码英文                      | 描述                                                         |
| --- | -------------------------- | ---------------------------------------------------------- |
| 500 | Internal Server Error      | 服务器内部错误，无法完成请求                                             |
| 501 | Not Implemented            | 服务器不支持请求的功能，无法完成请求                                         |
| 502 | Bad GateWay                | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接到一个无效的响应                      |
| 503 | Service Unavailable        | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。 延时的长度可包含在服务器的 Retry-After 头信息中 |
| 504 | Gateway Time-out           | 充当网关或代理的服务器，未及时从远端服务器获取请求                                  |
| 505 | HTTP Version not supported | 服务器不支持请求的 HTTP 协议的版本，无法完成处 理                               |



# TCP三次握手

## TCP三次握手

客户端和服务端都需要直到各自可收发，因此需要三次握手。

![img](https://shinoimg.yyshino.top/img/202304231122523.png)

从图片可以得到三次握手可以简化为：**C 发起请求连接** | **S 确认，发起连接** | **C 确认**

```
双方要连接，要等待对端同意并返回确认，一端请求后收到确认包就意味着，网络可达并且对端同意建立连接。最后的模型则是

A  --请求-->  B

A  <--确认--  B

A  <--请求--  B

A  --确认-->  B

中间两次可以一起返回，所以是三次握手
引自知乎@Manistein
```



## 三次握手的作用

### 过程

1. 第一次握手：客户端主动链接服务器，发送初始序列号`seq=x`与`SYN=1`同步请求标志，并进入同步已发送`SYN_SENT`状态，等待服务器确认。
2. 第二次握手：服务端收到消息后发送确认标志`ACK=1`与同步请求标志`SYN=1`，发送自己的序列号`seq=y`以及客户端确认序号`ack=x+1`，此时服务器进入同步收到`SYN_RECV`状态。
3. 第三次握手：客户端收到消息后发送确认标志`ACK=1`，发送自己的序列号`seq=x+1`与服务器确认号`ack=y+1`，发送过后即确认链接已建立状态`ESTABLISHED`，服务端接收确认信息后进入链接已建立状态`ESTABLISHED`



### 解释

1. 第一次握手：客户端：“兄弟，待会咱们出去玩吧，能看到我的消息吗，能就吱一声，让我知道我有发消息的能力”
2. 第二次握手：服务端：“吱，走走走咱们去哪玩？我收到你的消息了，你有发消息的能力，要不你再给我回个消息，让我也确定我有发消息的能力”
3. 第三次握手：客户端：“咱们先去河里摸鱼玩，然后上山摘点果子。我也收到你的消息了，你这发消息的能力也没问题，咱俩的发消息的能力都没问题，可以愉快的玩耍了”



## 四次挥手

```
client                                      server
主动关闭 →          FIN=1,seq=u          → 被动关闭，接收
(终止等待1)                               (关闭等待)
接收     ←      ACK=1,seq=v,ack=u+1      ← 发送
(终止等待2)                               (关闭等待)
接收     ←   FIN=1,ACK=1,seq=w,ack=u+1   ← 发送
(时间等待)                                (最后确认)
发送     →      ACK=1,seq=u+1,ack=w+1    → 接收
(时间等待 2MSL 关闭)                      (关闭)

来自@touchczy 的博客 https://blog.touchczy.top/#/Browser/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B
```

1. 第一次挥手：客户端发出释放标识`FIN=1`，自己的序列号`seq=u`，进入终止等待`FIN-WAIT-1`状态
2. 第二次挥手：服务端收到消息后发出`ACK=1`确认标志和客户端的确认号`ack=u+1`，自己的序列号`seq=v`，进入关闭等待`CLOSE-WAIT`状态，客户端收到消息后进入终止等待`FIN-WAIT-2`状态
3. 第三次挥手：服务器发送释放标识`FIN=1`信号，确认标志`ACK=1`，确认序号`ack=u+1`，自己的序列号`seq=w`，服务器进入最后确认`LAST-ACK`状态
4. 第四次挥手：客户端收到回复后，发送确认标志`ACK=1`，确认序号`ack=w+1`，自己的序列号`seq=u+1`，客户端进入时间等待`TIME-WAIT`状态，经过`2`个最长报文段寿命后，客户端`CLOSE`。服务器收到确认后，立刻进入`CLOSE`状态。

### 参考

[TCP三次握手 (touchczy.top)](https://blog.touchczy.top/#/Browser/TCP三次握手)

# TCP和UDP的区别

1. TCP 是**面向连接**的，udp 是**无连接**的即发送数据前不需要先建立链接。
2. TCP **提供可靠的服务**。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP **尽最大努力交付，即不保证可靠交付**。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。
3. TCP 是**面向字节流**，UDP **面向报文，并且网络出现拥塞不会使得发送速率降低**（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。
4. TCP 只能是 **1 对 1 的**，UDP 支持 **1 对 1,1 对多**。
5. TCP 的**首部较大为 20 字节**，而 UDP 只有 **8 字节**。
6. TCP 是**面向连接的可靠性传输**，而 UDP **是不可靠的**。


# WebSocket的实现和应用

## 什么是WebSocket

WebSocket 是HTML5的协议，支持持久性连接，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个 http 请求合并为 1 个

## WebSocket 是什么样的协议，具体有什么优点？

HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在 Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1 中进行了改进，是的有一个 connection： Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request，接收多个 Response。 但是必须记住，在 Http 中一个 Request 只能对应有一个 Response，而且这个 Response 是被动的，不能主动发起。 

**WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段 与 Http 是相同的。我们来看一个 websocket 握手协议的实现**，基本是 2 个属性，upgrade， connection。

```http
# 基本请求如下：
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
# 多了下面 2 个属性：告诉服务器发送的是 websocke
Upgrade:webSocket
Connection:Upgrade
```
