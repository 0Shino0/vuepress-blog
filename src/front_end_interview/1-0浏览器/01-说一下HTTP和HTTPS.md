---

title: 说一下HTTP和HTTPS
tags: 
   - HTTP
categories: 
   - 浏览器
summary: 说一下HTTP和HTTPS
description: 说一下HTTP和HTTPS
date: 2023-12-13
---



# 说一下HTTP和HTTPS

HTTPS的SSL加密是在传输层实现的。
## 基本概念

1. HTTP： 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
2. HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。
3. HTTPS协议的主要作用：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。



## 区别

HTTP数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 HTTP协议传输的数据进行加密处理，简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比HTTP 协议安全性更高



### 主要区别

1. HTTPS协议需要ca证书，费用较高
2. HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议。 
3. 使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443
4. HTTP连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP安全。



## 工作原理

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤

1. 客户端使用https url访问服务器，则要求 web 服务器**建立 ssl 链接**。 
2. web 服务器接收到客户端的请求之后，会将网站的**证书**（证书中包含了公钥），**返回或者说传输给客户端**。 
3. 客户端和 web 服务器端开始**协商 SSL 链接的安全等级**，也就是加密等级。 
4. 客户端浏览器通过双方协商一致的安全等级，**建立会话密钥**，然后通过网站的公钥来**加密会话密钥**，并**传送给网站**。 
5. web 服务器通过自己的私钥解密出会话密钥。 
6. web 服务器通过会话密钥加密与客户端之间的通信。



## HTTPS的优点

1. 使用 HTTPS 协议**可认证用户和服务器**，**确保数据发送到正确的客户机和服务器**；
2. HTTPS 协议是由 SSL+HTTP 协议构建的可进行**加密传输、身份认证的网络协议**，要比 http 协议安全，**可防止数据在传输过程中不被窃取、改变，确保数据的完整性**。 
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 
4. 谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。



## HTTPS的缺点

1. **https 握手阶段比较费时**，会使页面加载时间延长 50%，增加 10%~20%的耗电。 
2. **https 缓存不如 http 高效**，会增加数据开销。 SSL 证书也需要钱，功能越强大的证书费用越高。 
3. **SSL 证书需要绑定 IP**，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。


# TCP三次握手

## TCP三次握手

客户端和服务端都需要直到各自可收发，因此需要三次握手。

![img](https://shinoimg.yyshino.top/img/202304231122523.png)

从图片可以得到三次握手可以简化为：**C 发起请求连接** | **S 确认，发起连接** | **C 确认**

```
双方要连接，要等待对端同意并返回确认，一端请求后收到确认包就意味着，网络可达并且对端同意建立连接。最后的模型则是

A  --请求-->  B

A  <--确认--  B

A  <--请求--  B

A  --确认-->  B

中间两次可以一起返回，所以是三次握手
引自知乎@Manistein
```



## 三次握手的作用

### 过程

1. 第一次握手：客户端主动链接服务器，发送初始序列号`seq=x`与`SYN=1`同步请求标志，并进入同步已发送`SYN_SENT`状态，等待服务器确认。
2. 第二次握手：服务端收到消息后发送确认标志`ACK=1`与同步请求标志`SYN=1`，发送自己的序列号`seq=y`以及客户端确认序号`ack=x+1`，此时服务器进入同步收到`SYN_RECV`状态。
3. 第三次握手：客户端收到消息后发送确认标志`ACK=1`，发送自己的序列号`seq=x+1`与服务器确认号`ack=y+1`，发送过后即确认链接已建立状态`ESTABLISHED`，服务端接收确认信息后进入链接已建立状态`ESTABLISHED`



### 解释

1. 第一次握手：客户端：“兄弟，待会咱们出去玩吧，能看到我的消息吗，能就吱一声，让我知道我有发消息的能力”
2. 第二次握手：服务端：“吱，走走走咱们去哪玩？我收到你的消息了，你有发消息的能力，要不你再给我回个消息，让我也确定我有发消息的能力”
3. 第三次握手：客户端：“咱们先去河里摸鱼玩，然后上山摘点果子。我也收到你的消息了，你这发消息的能力也没问题，咱俩的发消息的能力都没问题，可以愉快的玩耍了”



## 四次挥手

```
client                                      server
主动关闭 →          FIN=1,seq=u          → 被动关闭，接收
(终止等待1)                               (关闭等待)
接收     ←      ACK=1,seq=v,ack=u+1      ← 发送
(终止等待2)                               (关闭等待)
接收     ←   FIN=1,ACK=1,seq=w,ack=u+1   ← 发送
(时间等待)                                (最后确认)
发送     →      ACK=1,seq=u+1,ack=w+1    → 接收
(时间等待 2MSL 关闭)                      (关闭)

来自@touchczy 的博客 https://blog.touchczy.top/#/Browser/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B
```

1. 第一次挥手：客户端发出释放标识`FIN=1`，自己的序列号`seq=u`，进入终止等待`FIN-WAIT-1`状态
2. 第二次挥手：服务端收到消息后发出`ACK=1`确认标志和客户端的确认号`ack=u+1`，自己的序列号`seq=v`，进入关闭等待`CLOSE-WAIT`状态，客户端收到消息后进入终止等待`FIN-WAIT-2`状态
3. 第三次挥手：服务器发送释放标识`FIN=1`信号，确认标志`ACK=1`，确认序号`ack=u+1`，自己的序列号`seq=w`，服务器进入最后确认`LAST-ACK`状态
4. 第四次挥手：客户端收到回复后，发送确认标志`ACK=1`，确认序号`ack=w+1`，自己的序列号`seq=u+1`，客户端进入时间等待`TIME-WAIT`状态，经过`2`个最长报文段寿命后，客户端`CLOSE`。服务器收到确认后，立刻进入`CLOSE`状态。

### 参考

[TCP三次握手 (touchczy.top)](https://blog.touchczy.top/#/Browser/TCP三次握手)

# TCP和UDP的区别

1. TCP 是**面向连接**的，udp 是**无连接**的即发送数据前不需要先建立链接。
2. TCP **提供可靠的服务**。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP **尽最大努力交付，即不保证可靠交付**。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。
3. TCP 是**面向字节流**，UDP **面向报文，并且网络出现拥塞不会使得发送速率降低**（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。
4. TCP 只能是 **1 对 1 的**，UDP 支持 **1 对 1,1 对多**。
5. TCP 的**首部较大为 20 字节**，而 UDP 只有 **8 字节**。
6. TCP 是**面向连接的可靠性传输**，而 UDP **是不可靠的**。


# WebSocket的实现和应用

## 什么是WebSocket

WebSocket 是HTML5的协议，支持持久性连接，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个 http 请求合并为 1 个

## WebSocket 是什么样的协议，具体有什么优点？

HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在 Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1 中进行了改进，是的有一个 connection： Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request，接收多个 Response。 但是必须记住，在 Http 中一个 Request 只能对应有一个 Response，而且这个 Response 是被动的，不能主动发起。 

**WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段 与 Http 是相同的。我们来看一个 websocket 握手协议的实现**，基本是 2 个属性，upgrade， connection。

```http
# 基本请求如下：
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
# 多了下面 2 个属性：告诉服务器发送的是 websocke
Upgrade:webSocket
Connection:Upgrade
```



